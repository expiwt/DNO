import numpy as np
import gmsh
import os

def create_quad_mesh_gmsh(params, scaled, mesh_size=0.25):
    """Создает триангуляцию четырехугольника с центральной точкой"""
    gmsh.model.add("quadrilateral")
    
    # ШАГ 1: Правильный порядок вершин четырехугольника
    quad_vertices = [
        [params[4], 0.0, 0.0],          # левая нижняя (x3, 0)
        [params[5], 0.0, 0.0],          # правая нижняя (x4, 0)
        [params[2], params[3], 0.0],    # правая верхняя (x2, y2)
        [params[0], params[1], 0.0],    # левая верхняя (x1, y1)
    ]
    
    # ШАГ 2: Вычисляем центральную точку (ПРАВИЛЬНО через индексы)
    center_x = (quad_vertices[0][0] + quad_vertices[1][0] + 
                quad_vertices[2][0] + quad_vertices[3][0]) / 4.0
    center_y = (quad_vertices[0][1] + quad_vertices[1][1] + 
                quad_vertices[2][1] + quad_vertices[3][1]) / 4.0
    
    # ШАГ 3: Добавляем центральную точку к вершинам
    vertices = quad_vertices + [[center_x, center_y, 0.0]]
    
    # ШАГ 4: Создание точек в Gmsh
    point_tags = []
    for vertex in vertices:
        tag = gmsh.model.occ.addPoint(float(vertex[0]), float(vertex[1]), float(vertex[2]))
        point_tags.append(tag)
    
    # ШАГ 5: Создание линий между углами четырехугольника (первые 4 точки)
    line_tags = []
    for i in range(4):
        line_tags.append(gmsh.model.occ.addLine(
            point_tags[i], 
            point_tags[(i+1) % 4]
        ))
    
    # ШАГ 6: Создание поверхности
    curve_loop = gmsh.model.occ.addCurveLoop(line_tags)
    surface = gmsh.model.occ.addPlaneSurface([curve_loop])
    gmsh.model.occ.synchronize()
    
    # ШАГ 7: Настройка размера сетки (КРИТИЧЕСКИЕ ПАРАМЕТРЫ)
    mesh_size_val = float(mesh_size * scaled)
    gmsh.option.setNumber("Mesh.MeshSizeMax", mesh_size_val)
    gmsh.option.setNumber("Mesh.MeshSizeMin", mesh_size_val * 0.4)
    gmsh.option.setNumber("Mesh.Algorithm", 6)  # Delaunay
    
    # ШАГ 8: Генерация сетки
    gmsh.model.mesh.generate(2)
    
    # ШАГ 9: ОПТИМИЗАЦИЯ качества (как в MATLAB!)
    gmsh.model.mesh.optimize("Netgen")
    
    # ШАГ 10: Получение узлов и элементов
    node_tags, node_coords, _ = gmsh.model.mesh.getNodes()
    element_types, element_tags, element_nodes = gmsh.model.mesh.getElements()
    
    # ШАГ 11: Правильное переиндексирование
    node_mapping = {tag: idx for idx, tag in enumerate(node_tags)}
    
    nodes = []
    for i in range(len(node_tags)):
        x = float(node_coords[3*i])
        y = float(node_coords[3*i + 1])
        nodes.append([x, y])
    
    # ШАГ 12: Извлечение треугольников с ПРАВИЛЬНЫМИ индексами
    triangles = []
    for i in range(len(element_types)):
        if element_types[i] == 2:  # 2D треугольники
            tri_nodes = element_nodes[i]
            for j in range(0, len(tri_nodes), 3):
                # tri_nodes содержит gmsh индексы (с 1)
                # node_mapping преобразует в индексы нашего массива (с 0)
                v0_idx = node_mapping[int(tri_nodes[j])]
                v1_idx = node_mapping[int(tri_nodes[j+1])]
                v2_idx = node_mapping[int(tri_nodes[j+2])]
                
                # Проверка ориентации (CCW)
                v0 = np.array(nodes[v0_idx])
                v1 = np.array(nodes[v1_idx])
                v2 = np.array(nodes[v2_idx])
                
                cross_z = (v1[0] - v0[0]) * (v2[1] - v0[1]) - (v1[1] - v0[1]) * (v2[0] - v0[0])
                
                if cross_z < 0:
                    v0_idx, v1_idx = v1_idx, v0_idx
                
                # OBJ индексы с 1, поэтому +1
                triangles.append([v0_idx + 1, v1_idx + 1, v2_idx + 1])
    
    gmsh.model.remove()  # Очистить для следующей итерации
    
    return np.array(nodes), np.array(triangles)

def save_obj(filename, vertices, triangles):
    """Сохраняет меш в OBJ формат"""
    with open(filename, 'w') as f:
        f.write("# OBJ File generated by Python Gmsh\n")
        
        # Вершины (индексы с 1)
        for vertex in vertices:
            x, y = float(vertex[0]), float(vertex[1])
            z = 1.45626e-007
            f.write(f"v {x:.6f} {y:.6f} {z:.6e}\n")
        
        # Треугольники (индексы уже правильные, с 1)
        for triangle in triangles:
            v1, v2, v3 = int(triangle[0]), int(triangle[1]), int(triangle[2])
            f.write(f"f {v1} {v2} {v3}\n")

# ============ ОСНОВНОЙ КОД ============

# Создаем папку
os.makedirs('part_obj', exist_ok=True)

# Загружаем данные
geo_data = np.loadtxt('geo_data_quad.csv', delimiter=',')

print(f"Загружено {len(geo_data)} четырехугольников")
print("Структура данных: [part_num, x1, y1, x2, y2, x3, x4, scale]")

# ИНИЦИАЛИЗИРУЕМ GMSH один раз
gmsh.initialize()

print("Начинаем генерацию OBJ файлов...\n")

for i, row in enumerate(geo_data):
    part_num = int(row[0])
    params = row[1:7]  # [x1, y1, x2, y2, x3, x4]
    scaled_val = float(row[7])  # масштаб
    
    print(f"Обрабатываем четырехугольник {part_num}: scale={scaled_val}")
    
    try:
        vertices, triangles = create_quad_mesh_gmsh(params, scaled_val, mesh_size=0.25)
        save_obj(f"part_obj/{part_num}.obj", vertices, triangles)
        print(f"   Успешно: {len(vertices)} вершин, {len(triangles)} треугольников\n")
        
    except Exception as e:
        print(f"   Ошибка: {e}")
        import traceback
        traceback.print_exc()
        print()

# ФИНАЛИЗИРУЕМ GMSH один раз
gmsh.finalize()

print(" Генерация завершена!")
